//
//  ParserTests.swift
//  File
//
//  Created by Jim Dovey on 9/14/21.
//

%{
    from gyb_utils import (autogenerated_warning, commonDice)

    modifiers = [
        ("Explode", ["!", "!!", "!p"], True, "comparison"),
        ("Minimum", ["min1"], False, ""),
        ("Maximum", ["max1"], False, ""),
        ("Reroll", ["r", "ro"], True, "comparison"),
        ("Keep", ["k", "kh", "kl"], False, ""),
        ("Drop", ["dh", "dl"], False, ""), # "d" isn't working right now...
        ("CriticalSuccess", ["cs"], True, "comparison"),
        ("CriticalFailure", ["cf"], True, "comparison"),
        ("Success", [""], True, "comparison"),
        ("Sorting", ["s", "sa", "sd"], False, "")
    ]

    requireComparisons = (
        "CriticalSuccess", "CriticalFailure", "Success", "Failure"
    )

    comparisons = [
        ("=", ".equal", "EqualTo"),
        ("!=", ".notEqual", "NotEqualTo"),
        ("<>", ".notEqual", "AlternateNotEqualTo"),
        (">", ".greater", "GreaterThan"),
        ("<", ".lesser", "LessThan"),
        (">=", ".greaterEqual", "GreaterThanOrEqual"),
        ("<=", ".lesserEqual", "LessThanOrEqual"),
    ]

    comparisonCapableModifiers = [

    ]

    keepDrop = [
        ("k", "Keep", "count:"),
        ("kh", "Keep", "count:"),
        ("kl", "Keep", "high: false, count:"),
        ("dl", "Drop", "count:"),
        ("dh", "Drop", "high: true, count:")
    ]
}%
${autogenerated_warning()}

import XCTest
@testable import DiceRoller

class ParserTests: XCTestCase {
    let roller = DiceRoller()

    func testStandardDice() throws {
        var expression: Expression
% for die in commonDice:
        expression = try roller.decodeExpression(from: "d${die}")
        XCTAssertEqual(expression, .roll(Roll(dice: .standard(sides: ${die}, count: 1))))
%   for count in range(1, 5):
        expression = try roller.decodeExpression(from: "${count}d${die}")
        XCTAssertEqual(expression, .roll(Roll(dice: .standard(sides: ${die}, count: ${count}))))
%   end
% end
    }

    func testPercentageDice() throws {
        var expression: Expression
        expression = try roller.decodeExpression(from: "d%")
        XCTAssertEqual(expression, .roll(Roll(dice: .percent(count: 1))))
% for count in range(1, 5):
        expression = try roller.decodeExpression(from: "${count}d%")
        XCTAssertEqual(expression, .roll(Roll(dice: .percent(count: ${count}))))
% end
    }

    func testFateDice() throws {
        var expression: Expression
        expression = try roller.decodeExpression(from: "dF")
        XCTAssertEqual(expression, .roll(Roll(dice: .fate(lowProbability: false, count: 1))))
        expression = try roller.decodeExpression(from: "dF.2")
        XCTAssertEqual(expression, .roll(Roll(dice: .fate(lowProbability: false, count: 1))))
        expression = try roller.decodeExpression(from: "dF.1")
        XCTAssertEqual(expression, .roll(Roll(dice: .fate(lowProbability: true, count: 1))))
% for count in range(1, 5):
        expression = try roller.decodeExpression(from: "${count}dF")
        XCTAssertEqual(expression, .roll(Roll(dice: .fate(lowProbability: false, count: ${count}))))
        expression = try roller.decodeExpression(from: "${count}dF.2")
        XCTAssertEqual(expression, .roll(Roll(dice: .fate(lowProbability: false, count: ${count}))))
        expression = try roller.decodeExpression(from: "${count}dF.1")
        XCTAssertEqual(expression, .roll(Roll(dice: .fate(lowProbability: true, count: ${count}))))
% end
    }

    func testMinimums() throws {
        var expression: Expression
        var modifier: Modifier
% for n in range(1, 6):
        modifier = Modifiers.Minimum(value: ${n})
        expression = try roller.decodeExpression(from: "4d6min${n}")
        XCTAssertEqual(expression, .roll(Roll(dice: .standard(sides: 6, count: 4), modifiers: [modifier])))
% end
    }

    func testMaximums() throws {
        var expression: Expression
        var modifier: Modifier
% for n in range(1, 6):
        modifier = Modifiers.Maximum(value: ${n})
        expression = try roller.decodeExpression(from: "4d6max${n}")
        XCTAssertEqual(expression, .roll(Roll(dice: .standard(sides: 6, count: 4), modifiers: [modifier])))
% end
    }

    func testKeepDrop() throws {
        var expression: Expression
        var modifier: Modifier
% for flag, type, args in keepDrop:
        modifier = Modifiers.${type}(${args} 1)
        expression = try roller.decodeExpression(from: "4d6${flag}")
        XCTAssertEqual(expression, .roll(Roll(dice: .standard(sides: 6, count: 4), modifiers: [modifier])))
%   for n in range(1, 6):
        modifier = Modifiers.${type}(${args} ${n})
        expression = try roller.decodeExpression(from: "4d6${flag}${n}")
        XCTAssertEqual(expression, .roll(Roll(dice: .standard(sides: 6, count: 4), modifiers: [modifier])))
%   end
% end
    }

    func testModifierIdentities() throws {
        var expression: Expression
% for type, flags, _, _ in modifiers:
%   if type not in requireComparisons:
%     for flag in flags:
        expression = try roller.decodeExpression(from: "4d6${flag}")
        guard case let .roll(roll) = expression else {
            XCTFail("Expected roll with ${type} modifier from '4d6${flag}' input")
            return
        }
        XCTAssertEqual(roll.modifiers.count, 1, "Expected 1 modifier from '4d6${flag}'")
        XCTAssertTrue(roll.modifiers.first is Modifiers.${type})
%     end
%   end
% end
    }

% for type, flags, usesComparisons, property in modifiers:
%   if usesComparisons:
    func test${type}ModifierWithComparisons() throws {
        var expression: Expression
        var comparison: ComparisonPoint
% for operator, identifier, name in comparisons:

%   for flag in flags:
%     if not (type == "Explode" and operator == "!="):
        // ${name}
        comparison = ComparisonPoint(comparison: ${identifier}, value: 3)
        expression = try roller.decodeExpression(from: "4d6${flag}${operator}3")
        guard case let .roll(roll) = expression else {
            XCTFail("Expected roll with ${type} modifier from '4d6${flag}${operator}3' input")
            return
        }
        XCTAssertEqual(roll.modifiers.count, 1, "Expected 1 modifier from '4d6${flag}${operator}3'")
        XCTAssertTrue(roll.modifiers.first is Modifiers.${type})
        XCTAssertEqual((roll.modifiers.first as? Modifiers.${type})?.comparison, comparison)
%     end
%   end
% end
    }
%   end
% end
}
