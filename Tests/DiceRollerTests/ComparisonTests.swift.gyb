//
//  File.swift
//  File
//
//  Created by Jim Dovey on 9/13/21.
//

%{
    from gyb_utils import (autogenerated_warning)

    operators = [
        (".equal",        "Equal",        "rollHigh",   "{ n }",    "1"),
        (".notEqual",     "NotEqual",     "{ n }",      "{ n+1 }",  "5"),
        (".greater",      "GreaterThan",  "rollLow",    "rollHigh", "inputs.count - n"),
        (".greaterEqual", "GreaterEqual", "rollLow",    "rollHigh", "inputs.count - (n-1)"),
        (".lesser",       "LessThan",     "rollHigh",   "rollLow",  "n-1"),
        (".lesserEqual",  "LessEqual",    "rollHigh",   "rollLow",  "n"),
    ]

    modifiers = [
        ("Explodes",        "!",    False,  True,   "Explode(comparison: comparison)"),
        ("Compounds",       "!!",   False,  False,  "Explode(comparison: comparison, format: .compounding)"),
        ("Penetrates",      "!p",   False,  True,   "Explode(comparison: comparison, format: .penetrating)"),
        ("Rerolls",         "r",    False,  False,  "Reroll(comparison: comparison)"),
        ("RerollsOnce",     "ro",   True,   False,  "Reroll(once: true, comparison: comparison)"),
        ("Success",         "*",    False,  False,  "Success(comparison: comparison)"),
        ("CriticalSuccess", "**",   False,  False,  "CriticalSuccess(comparison: comparison)"),
        ("CriticalFailure", "__",   False,  False,  "CriticalFailure(comparison: comparison)")
    ]
}%
${autogenerated_warning()}

import XCTest
@testable import DiceRoller

// These tests are designed to feed in a set of predefined values, and will
// expect one of these values to match the comparison point.  They provide rolls
// that will always FAIL to match the comparison point, so that we can predict
// how many dice will have matched, even when extra dice have been rolled.

class ComparisonTests: XCTestCase {
    let inputs = [1, 2, 3, 4, 5, 6]
    lazy var results = inputs.map { RollResult(value: $0) }

    func rollOne() -> Int { 1 }
    func rollHigh() -> Int { 500 }
    func rollLow() -> Int { -500 }

% for op, name, failRoll, matchRoll, resultCount in operators:
    func testBasic${name}Comparison() {
        for n in inputs {
            let comparison = ComparisonPoint(comparison: ${op}, value: n)
            let results = inputs.compactMap { comparison.compare($0) ? 1 : nil }
            XCTAssertEqual(results.count, ${resultCount})
        }
    }

% for mod, flag, usesMatchRoll, addsDice, builder in modifiers:
    func test${mod}On${name}Comparison() {
        for n in inputs {
            let comparison = ComparisonPoint(comparison: ${op}, value: n)
            let modifier = Modifiers.${builder}
            var results = self.results
            results = modifier.run(
                for: results,
%   if usesMatchRoll:
                using: ${matchRoll}
%   else:
                using: ${failRoll}
%   end
            )
            XCTAssertEqual(
                ${resultCount}, results.filter({ $0.modifierFlags == "${flag}" }).count,
                "Unexpected count for n=\(n)"
            )

            XCTAssertEqual(
                results.count,
                inputs.count
%   if addsDice:
                    + (${resultCount})
%   end
                , "Unexpected count for n=\(n)"
            )
        }
    }

% end # modifiers
% end # comparisons
}
