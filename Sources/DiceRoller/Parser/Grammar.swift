// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Preface

#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 13)

import CitronParserModule
import CitronLexerModule

#sourceLocation()

// Parser class

class DiceRollParser: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case Explode                        =   1
      case Compound                       =   2
      case Penetrate                      =   3
      case Reroll                         =   4
      case RerollOnce                     =   5
      case Critical                       =   6
      case Fumble                         =   7
      case Sort                           =   8
      case Equal                          =   9
      case NotEqual                       =  10
      case Greater                        =  11
      case GreaterEqual                   =  12
      case Lesser                         =  13
      case LesserEqual                    =  14
      case Add                            =  15
      case Subtract                       =  16
      case Multiply                       =  17
      case Divide                         =  18
      case Modulo                         =  19
      case Power                          =  20
      case Die                            =  21
      case Fail                           =  22
      case KeepHigh                       =  23
      case Integer                        =  24
      case KeepLow                        =  25
      case DropLow                        =  26
      case DropHigh                       =  27
      case Min                            =  28
      case Max                            =  29
      case SortAscending                  =  30
      case SortDescending                 =  31
      case StandardDie                    =  32
      case PercentageDie                  =  33
      case FudgeDie                       =  34
      case OpenParen                      =  35
      case CloseParen                     =  36
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case expr                           =  37
      case expr_list                      =  38
      case root                           =  39
      case modifier                       =  40
      case modifier_list                  =  41
      case compare_point                  =  42
      case dice                           =  43
      case roll                           =  44
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 37) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 45) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = (token: Token, position: CitronLexerPosition)

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy5(Expression)
        case yy29([Expression])
        case yy30(Modifier)
        case yy40(Dice)
        case yy48([Modifier])
        case yy52(ComparisonPoint)
        case yy66(Roll)

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy5(let value): return value as Any
            case .yy29(let value): return value as Any
            case .yy30(let value): return value as Any
            case .yy40(let value): return value as Any
            case .yy48(let value): return value as Any
            case .yy52(let value): return value as Any
            case .yy66(let value): return value as Any
            }
        }
    }

    typealias CitronResult = Expression

    // Counts

    let yyNumberOfSymbols: Int = 45
    let yyNumberOfStates: Int = 39

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  ( 1, .SH(12)), ( 2, .SH(11)), ( 3, .SH(10)), ( 4, .SH(16)), ( 5, .SH(15)),
/*   5 */  ( 6, .SH(14)), ( 7, .SH(13)), (42, .RD(25)), ( 9, .SH(37)), (10, .SH(36)),
/*  10 */  (11, .SH(35)), (12, .SH(34)), (13, .SH(33)), (14, .SH(32)), (42, .RD(23)),
/*  15 */  (15, .SH( 9)), (16, .SH( 8)), (17, .SH( 7)), (18, .SH( 6)), (19, .SH( 5)),
/*  20 */  (20, .SH( 4)), (42, .RD(21)), (23, .SH(31)), ( 0, .RD( 0)), (25, .SH(30)),
/*  25 */  (26, .SH(29)), (27, .SH(28)), (28, .SH(27)), (29, .SH(26)), (30, .SR(19)),
/*  30 */  (31, .SR(20)), (17, .SH( 7)), (18, .SH( 6)), (19, .SH( 5)), (20, .SH( 4)),
/*  35 */  (42, .RD(18)), (36, .SR(40)), (42, .RD(17)), (15, .SH( 9)), (16, .SH( 8)),
/*  40 */  (17, .SH( 7)), (18, .SH( 6)), (19, .SH( 5)), (20, .SH( 4)), (24, .SR(38)),
/*  45 */  (42, .RD(15)), ( 9, .SH(37)), (10, .SH(36)), (11, .SH(35)), (12, .SH(34)),
/*  50 */  (13, .SH(33)), (14, .SH(32)), (32, .SR(27)), (33, .SR(28)), (34, .SR(29)),
/*  55 */  (35, .SH( 3)), (37, .SH(19)), (42, .RD(13)), (39, .ACCEPT),   (42, .RD( 1)),
/*  60 */  (20, .SH( 4)), (22, .SH(17)), (43, .SH( 2)), (44, .RD(39)), (40, .SH( 1)),
/*  65 */  (41, .RD(42)), (42, .SH(38)), (40, .SH( 1)), (41, .RD(30)), (42, .SH(38)),
/*  70 */  (37, .SH(18)), (45, .RD( 2)), (37, .SH(22)), (24, .SR(12)), (24, .SR(11)),
/*  75 */  (24, .SR( 9)), (43, .SH( 2)), (44, .RD(39)), (43, .SH( 2)), (44, .RD(39)),
/*  80 */  (37, .SH(23)), (45, .RD( 2)), (37, .SH(24)), (24, .SR( 7)), (37, .SH(25)),
/*  85 */  (24, .SR( 5)), (43, .SH( 2)), (44, .RD(39)), (43, .SH( 2)), (44, .RD(39)),
/*  90 */  (43, .SH( 2)), (44, .RD(39)), (37, .SH(20)), (24, .SR( 3)), (37, .SH(21)),
/*  95 */  (24, .SR(48)), (45, .RD( 2)), (24, .SR(47)), (43, .SH( 2)), (44, .RD(39)),
/* 100 */  (43, .SH( 2)), (44, .RD(39)), (24, .SR(46)), (24, .SR(45)), (24, .SR(44)),
/* 105 */  (24, .SR(43)),
    ]

    let yyShiftUseDefault: Int = 106
    let yyShiftOffsetMin: Int = -1
    let yyShiftOffsetMax: Int = 81
    let yyShiftOffset: [Int] = [
        /*     0 */    20,   -1,   -1,   20,   20,   20,   20,   20,   20,   20,
        /*    10 */    37,   37,   37,   37,   37,   37,   37,   37,    0,   23,
        /*    20 */    14,   14,   40,   40,   40,   40,   49,   50,   51,   59,
        /*    30 */    61,   69,   71,   73,   78,   79,   80,   81,   39,
    ]

    let yyReduceUseDefault: Int = -36
    let yyReduceOffsetMin: Int =   -35
    let yyReduceOffsetMax: Int =   57
    let yyReduceOffset: [Int] = [
        /*     0 */    19,   24,   27,   33,   35,   43,   45,   47,   55,   57,
        /*    10 */   -35,  -28,  -21,   -7,   -5,    3,   15,   17,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .ERROR , .RD(41), .RD(31), .ERROR , .ERROR ,
  /*     5 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    10 */  .RD(26), .RD(24), .RD(22), .ERROR , .ERROR ,
  /*    15 */  .RD(16), .RD(14), .ERROR , .ERROR , .ERROR ,
  /*    20 */  .RD(33), .RD(32), .RD(37), .RD(36), .RD(35),
  /*    25 */  .RD(34), .ERROR , .ERROR , .RD(10), .RD( 8),
  /*    30 */  .RD( 6), .RD( 4), .ERROR , .ERROR , .ERROR ,
  /*    35 */  .ERROR , .ERROR , .ERROR , .RD( 2),
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 39, nrhs: 1),
        (lhs: 41, nrhs: 3),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 40, nrhs: 2),
        (lhs: 40, nrhs: 1),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 1),
        (lhs: 44, nrhs: 2),
        (lhs: 44, nrhs: 1),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 1),
        (lhs: 37, nrhs: 1),
        (lhs: 37, nrhs: 3),
        (lhs: 41, nrhs: 1),
        (lhs: 41, nrhs: 2),
        (lhs: 42, nrhs: 2),
        (lhs: 42, nrhs: 2),
        (lhs: 42, nrhs: 2),
        (lhs: 42, nrhs: 2),
        (lhs: 42, nrhs: 2),
        (lhs: 42, nrhs: 2),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    var isTracingPrintsSymbolValues: Bool = false
    var isTracingPrintsTokenValues: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "Explode",
    /*  2 */ "Compound",
    /*  3 */ "Penetrate",
    /*  4 */ "Reroll",
    /*  5 */ "RerollOnce",
    /*  6 */ "Critical",
    /*  7 */ "Fumble",
    /*  8 */ "Sort",
    /*  9 */ "Equal",
    /* 10 */ "NotEqual",
    /* 11 */ "Greater",
    /* 12 */ "GreaterEqual",
    /* 13 */ "Lesser",
    /* 14 */ "LesserEqual",
    /* 15 */ "Add",
    /* 16 */ "Subtract",
    /* 17 */ "Multiply",
    /* 18 */ "Divide",
    /* 19 */ "Modulo",
    /* 20 */ "Power",
    /* 21 */ "Die",
    /* 22 */ "Fail",
    /* 23 */ "KeepHigh",
    /* 24 */ "Integer",
    /* 25 */ "KeepLow",
    /* 26 */ "DropLow",
    /* 27 */ "DropHigh",
    /* 28 */ "Min",
    /* 29 */ "Max",
    /* 30 */ "SortAscending",
    /* 31 */ "SortDescending",
    /* 32 */ "StandardDie",
    /* 33 */ "PercentageDie",
    /* 34 */ "FudgeDie",
    /* 35 */ "OpenParen",
    /* 36 */ "CloseParen",
    /* 37 */ "expr",
    /* 38 */ "expr_list",
    /* 39 */ "root",
    /* 40 */ "modifier",
    /* 41 */ "modifier_list",
    /* 42 */ "compare_point",
    /* 43 */ "dice",
    /* 44 */ "roll",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "root ::= expr(a)",
        /*   1 */ "modifier_list ::= compare_point(scp) Fail compare_point(fcp)",
        /*   2 */ "modifier ::= compare_point(cp)",
        /*   3 */ "modifier ::= KeepHigh Integer(a)",
        /*   4 */ "modifier ::= KeepHigh",
        /*   5 */ "modifier ::= KeepLow Integer(a)",
        /*   6 */ "modifier ::= KeepLow",
        /*   7 */ "modifier ::= DropLow Integer(a)",
        /*   8 */ "modifier ::= DropLow",
        /*   9 */ "modifier ::= DropHigh Integer(a)",
        /*  10 */ "modifier ::= DropHigh",
        /*  11 */ "modifier ::= Min Integer(a)",
        /*  12 */ "modifier ::= Max Integer(a)",
        /*  13 */ "modifier ::= Reroll compare_point(cp)",
        /*  14 */ "modifier ::= Reroll",
        /*  15 */ "modifier ::= RerollOnce compare_point(cp)",
        /*  16 */ "modifier ::= RerollOnce",
        /*  17 */ "modifier ::= Critical compare_point(cp)",
        /*  18 */ "modifier ::= Fumble compare_point(cp)",
        /*  19 */ "modifier ::= SortAscending",
        /*  20 */ "modifier ::= SortDescending",
        /*  21 */ "modifier ::= Explode compare_point(cp)",
        /*  22 */ "modifier ::= Explode",
        /*  23 */ "modifier ::= Compound compare_point(cp)",
        /*  24 */ "modifier ::= Compound",
        /*  25 */ "modifier ::= Penetrate compare_point(cp)",
        /*  26 */ "modifier ::= Penetrate",
        /*  27 */ "dice ::= StandardDie(d)",
        /*  28 */ "dice ::= PercentageDie(d)",
        /*  29 */ "dice ::= FudgeDie(d)",
        /*  30 */ "roll ::= dice(d) modifier_list(mods)",
        /*  31 */ "roll ::= dice(d)",
        /*  32 */ "expr ::= expr(a) Add expr(b)",
        /*  33 */ "expr ::= expr(a) Subtract expr(b)",
        /*  34 */ "expr ::= expr(a) Multiply expr(b)",
        /*  35 */ "expr ::= expr(a) Divide expr(b)",
        /*  36 */ "expr ::= expr(a) Modulo expr(b)",
        /*  37 */ "expr ::= expr(a) Power expr(b)",
        /*  38 */ "expr ::= Integer(a)",
        /*  39 */ "expr ::= roll(a)",
        /*  40 */ "expr ::= OpenParen expr(a) CloseParen",
        /*  41 */ "modifier_list ::= modifier(a)",
        /*  42 */ "modifier_list ::= modifier(a) modifier_list(b)",
        /*  43 */ "compare_point ::= Equal Integer(a)",
        /*  44 */ "compare_point ::= NotEqual Integer(a)",
        /*  45 */ "compare_point ::= Greater Integer(a)",
        /*  46 */ "compare_point ::= GreaterEqual Integer(a)",
        /*  47 */ "compare_point ::= Lesser Integer(a)",
        /*  48 */ "compare_point ::= LesserEqual Integer(a)",
    ]

    // Extra class members


    var currentDieMax: Int = 6


    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* root ::= expr(a) */
            func codeBlockForRule00(a: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 42)
 return a 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule00(a: a))
            }
        case 1: /* modifier_list ::= compare_point(scp) Fail compare_point(fcp) */
            func codeBlockForRule01(scp: ComparisonPoint, fcp: ComparisonPoint) throws -> [Modifier] {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 67)

    return [
        Modifiers.Success(comparison: scp),
        Modifiers.Failure(comparison: fcp)
    ]

#sourceLocation()
}
            if case .yy52(let scp) = yySymbolOnStack(distanceFromTop: 2),
               case .yy52(let fcp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy48(try codeBlockForRule01(scp: scp, fcp: fcp))
            }
        case 2: /* modifier ::= compare_point(cp) */
            func codeBlockForRule02(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 73)

    return Modifiers.Success(comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule02(cp: cp))
            }
        case 3: /* modifier ::= KeepHigh Integer(a) */
            func codeBlockForRule03(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 79)

    return Modifiers.Keep(high: true, count: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule03(a: a))
            }
        case 4: /* modifier ::= KeepHigh */
            func codeBlockForRule04() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 82)

    return Modifiers.Keep(high: true, count: 1)

#sourceLocation()
}
            return .yy30(try codeBlockForRule04())
        case 5: /* modifier ::= KeepLow Integer(a) */
            func codeBlockForRule05(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 85)

    return Modifiers.Keep(high: false, count: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule05(a: a))
            }
        case 6: /* modifier ::= KeepLow */
            func codeBlockForRule06() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 88)

    return Modifiers.Keep(high: false, count: 1)

#sourceLocation()
}
            return .yy30(try codeBlockForRule06())
        case 7: /* modifier ::= DropLow Integer(a) */
            func codeBlockForRule07(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 92)

    return Modifiers.Drop(high: false, count: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule07(a: a))
            }
        case 8: /* modifier ::= DropLow */
            func codeBlockForRule08() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 95)

    return Modifiers.Drop(high: false, count: 1)

#sourceLocation()
}
            return .yy30(try codeBlockForRule08())
        case 9: /* modifier ::= DropHigh Integer(a) */
            func codeBlockForRule09(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 98)

    return Modifiers.Drop(high: true, count: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule09(a: a))
            }
        case 10: /* modifier ::= DropHigh */
            func codeBlockForRule10() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 101)

    return Modifiers.Drop(high: true, count: 1)

#sourceLocation()
}
            return .yy30(try codeBlockForRule10())
        case 11: /* modifier ::= Min Integer(a) */
            func codeBlockForRule11(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 107)

    return Modifiers.Minimum(value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule11(a: a))
            }
        case 12: /* modifier ::= Max Integer(a) */
            func codeBlockForRule12(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 110)

    return Modifiers.Maximum(value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule12(a: a))
            }
        case 13: /* modifier ::= Reroll compare_point(cp) */
            func codeBlockForRule13(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 116)

    return Modifiers.Reroll(comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule13(cp: cp))
            }
        case 14: /* modifier ::= Reroll */
            func codeBlockForRule14() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 119)

    return Modifiers.Reroll()

#sourceLocation()
}
            return .yy30(try codeBlockForRule14())
        case 15: /* modifier ::= RerollOnce compare_point(cp) */
            func codeBlockForRule15(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 122)

    return Modifiers.Reroll(once: true, comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule15(cp: cp))
            }
        case 16: /* modifier ::= RerollOnce */
            func codeBlockForRule16() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 125)

    return Modifiers.Reroll(once: true)

#sourceLocation()
}
            return .yy30(try codeBlockForRule16())
        case 17: /* modifier ::= Critical compare_point(cp) */
            func codeBlockForRule17(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 131)

    return Modifiers.CriticalSuccess(comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule17(cp: cp))
            }
        case 18: /* modifier ::= Fumble compare_point(cp) */
            func codeBlockForRule18(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 134)

    return Modifiers.CriticalFailure(comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule18(cp: cp))
            }
        case 19: /* modifier ::= SortAscending */
            func codeBlockForRule19() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 140)

    return Modifiers.Sorting(ascending: true)

#sourceLocation()
}
            return .yy30(try codeBlockForRule19())
        case 20: /* modifier ::= SortDescending */
            func codeBlockForRule20() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 143)

    return Modifiers.Sorting(ascending: false)

#sourceLocation()
}
            return .yy30(try codeBlockForRule20())
        case 21: /* modifier ::= Explode compare_point(cp) */
            func codeBlockForRule21(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 149)

    return Modifiers.Explode(comparison: cp, format: .exploding)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule21(cp: cp))
            }
        case 22: /* modifier ::= Explode */
            func codeBlockForRule22() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 152)

    let cp = ComparisonPoint(comparison: .maxRoll, value: currentDieMax)
    return Modifiers.Explode(comparison: cp, format: .exploding)

#sourceLocation()
}
            return .yy30(try codeBlockForRule22())
        case 23: /* modifier ::= Compound compare_point(cp) */
            func codeBlockForRule23(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 156)

    return Modifiers.Explode(comparison: cp, format: .compounding)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule23(cp: cp))
            }
        case 24: /* modifier ::= Compound */
            func codeBlockForRule24() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 159)

    let cp = ComparisonPoint(comparison: .maxRoll, value: currentDieMax)
    return Modifiers.Explode(comparison: cp, format: .compounding)

#sourceLocation()
}
            return .yy30(try codeBlockForRule24())
        case 25: /* modifier ::= Penetrate compare_point(cp) */
            func codeBlockForRule25(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 163)

    return Modifiers.Explode(comparison: cp, format: .penetrating)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule25(cp: cp))
            }
        case 26: /* modifier ::= Penetrate */
            func codeBlockForRule26() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 166)

    let cp = ComparisonPoint(comparison: .maxRoll, value: currentDieMax)
    return Modifiers.Explode(comparison: cp, format: .penetrating)

#sourceLocation()
}
            return .yy30(try codeBlockForRule26())
        case 27: /* dice ::= StandardDie(d) */
            func codeBlockForRule27(d: (token: Token, position: CitronLexerPosition)) throws -> Dice {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 176)

    currentDieMax = d.token.sides
    return .standard(sides: d.token.sides, count: d.token.count)

#sourceLocation()
}
            if case .yy0(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule27(d: d))
            }
        case 28: /* dice ::= PercentageDie(d) */
            func codeBlockForRule28(d: (token: Token, position: CitronLexerPosition)) throws -> Dice {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 180)

    currentDieMax = 100
    return .percent(count: d.token.value)

#sourceLocation()
}
            if case .yy0(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule28(d: d))
            }
        case 29: /* dice ::= FudgeDie(d) */
            func codeBlockForRule29(d: (token: Token, position: CitronLexerPosition)) throws -> Dice {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 184)

    currentDieMax = 1
    return .fate(lowProbability: d.token.lowFate, count: d.token.count)

#sourceLocation()
}
            if case .yy0(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule29(d: d))
            }
        case 30: /* roll ::= dice(d) modifier_list(mods) */
            func codeBlockForRule30(d: Dice, mods: [Modifier]) throws -> Roll {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 194)

    return Roll(dice: d, modifiers: mods)

#sourceLocation()
}
            if case .yy40(let d) = yySymbolOnStack(distanceFromTop: 1),
               case .yy48(let mods) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy66(try codeBlockForRule30(d: d, mods: mods))
            }
        case 31: /* roll ::= dice(d) */
            func codeBlockForRule31(d: Dice) throws -> Roll {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 197)

    return Roll(dice: d)

#sourceLocation()
}
            if case .yy40(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy66(try codeBlockForRule31(d: d))
            }
        case 32: /* expr ::= expr(a) Add expr(b) */
            func codeBlockForRule32(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 204)
 return .addition(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule32(a: a, b: b))
            }
        case 33: /* expr ::= expr(a) Subtract expr(b) */
            func codeBlockForRule33(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 205)
 return .subtraction(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule33(a: a, b: b))
            }
        case 34: /* expr ::= expr(a) Multiply expr(b) */
            func codeBlockForRule34(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 206)
 return .multiplication(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule34(a: a, b: b))
            }
        case 35: /* expr ::= expr(a) Divide expr(b) */
            func codeBlockForRule35(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 207)
 return .division(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule35(a: a, b: b))
            }
        case 36: /* expr ::= expr(a) Modulo expr(b) */
            func codeBlockForRule36(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 208)
 return .modulus(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule36(a: a, b: b))
            }
        case 37: /* expr ::= expr(a) Power expr(b) */
            func codeBlockForRule37(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 209)
 return .power(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule37(a: a, b: b))
            }
        case 38: /* expr ::= Integer(a) */
            func codeBlockForRule38(a: (token: Token, position: CitronLexerPosition)) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 214)
 return .number(a.token.value) 
#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule38(a: a))
            }
        case 39: /* expr ::= roll(a) */
            func codeBlockForRule39(a: Roll) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 215)
 return .roll(a) 
#sourceLocation()
}
            if case .yy66(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule39(a: a))
            }
        case 40: /* expr ::= OpenParen expr(a) CloseParen */
            func codeBlockForRule40(a: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 216)
 return .braced(a) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy5(try codeBlockForRule40(a: a))
            }
        case 41: /* modifier_list ::= modifier(a) */
            func codeBlockForRule41(a: Modifier) throws -> [Modifier] {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 224)
 return [a] 
#sourceLocation()
}
            if case .yy30(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy48(try codeBlockForRule41(a: a))
            }
        case 42: /* modifier_list ::= modifier(a) modifier_list(b) */
            func codeBlockForRule42(a: Modifier, b: [Modifier]) throws -> [Modifier] {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 225)
 return [a] + b 
#sourceLocation()
}
            if case .yy30(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy48(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy48(try codeBlockForRule42(a: a, b: b))
            }
        case 43: /* compare_point ::= Equal Integer(a) */
            func codeBlockForRule43(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 233)

    return ComparisonPoint(comparison: .equal, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule43(a: a))
            }
        case 44: /* compare_point ::= NotEqual Integer(a) */
            func codeBlockForRule44(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 236)

    return ComparisonPoint(comparison: .notEqual, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule44(a: a))
            }
        case 45: /* compare_point ::= Greater Integer(a) */
            func codeBlockForRule45(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 239)

    return ComparisonPoint(comparison: .greater, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule45(a: a))
            }
        case 46: /* compare_point ::= GreaterEqual Integer(a) */
            func codeBlockForRule46(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 242)

    return ComparisonPoint(comparison: .greaterEqual, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule46(a: a))
            }
        case 47: /* compare_point ::= Lesser Integer(a) */
            func codeBlockForRule47(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 245)

    return ComparisonPoint(comparison: .lesser, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule47(a: a))
            }
        case 48: /* compare_point ::= LesserEqual Integer(a) */
            func codeBlockForRule48(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 248)

    return ComparisonPoint(comparison: .lesserEqual, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule48(a: a))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy5(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _DiceRollParserCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [
          0 : [39, 43, 37],
          1 : [40, 42],
          2 : [40, 42],
          3 : [43, 37],
          4 : [43, 37],
          5 : [43, 37],
          6 : [43, 37],
          7 : [43, 37],
          8 : [43, 37],
          9 : [43, 37],
         10 : [42],
         11 : [42],
         12 : [42],
         13 : [42],
         14 : [42],
         15 : [42],
         16 : [42],
         17 : [42],
    ]
    let yyCanErrorCapture: Bool = true
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [
        37 : (endAfter: [],
              endBefore: [.CloseParen]),
        40 : (endAfter: [],
              endBefore: [.CloseParen, .Add, .Subtract, .Multiply, .Divide, .Modulo, .Power]),
        42 : (endAfter: [],
              endBefore: [.CloseParen, .Add, .Subtract, .Multiply, .Divide, .Modulo, .Power]),
        43 : (endAfter: [],
              endBefore: [.CloseParen])
    ]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = [
        15, 16, 17, 18, 19, 20, 36
    ]
    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = [
        
    ]

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        guard let delegate = errorCaptureDelegate else {
            print("Error capture: Not saving error for capturing because errorCaptureDelegate is not set")
            return false
        }
        return delegate.shouldSaveErrorForCapturing(error: error)
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        guard let delegate = errorCaptureDelegate else {
            print("Error capture: Not capturing error because errorCaptureDelegate is not set")
            return nil
        }

        switch (symbolCode) {
        case .expr:
            let delegateResponse = delegate.shouldCaptureErrorOnExpr(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy5(symbol)
            case .dontCapture:
                return nil
            }
        case .root:
            let delegateResponse = delegate.shouldCaptureErrorOnRoot(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy5(symbol)
            case .dontCapture:
                return nil
            }
        case .modifier:
            let delegateResponse = delegate.shouldCaptureErrorOnModifier(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy30(symbol)
            case .dontCapture:
                return nil
            }
        case .compare_point:
            let delegateResponse = delegate.shouldCaptureErrorOnCompare_point(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy52(symbol)
            case .dontCapture:
                return nil
            }
        case .dice:
            let delegateResponse = delegate.shouldCaptureErrorOnDice(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy40(symbol)
            case .dontCapture:
                return nil
            }
        default:
            fatalError("yyCaptureError: Symbol code \(symbolCode) is not an error capturing symbol code")
        }
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 39
    let yyEndStateNumber: CitronStateNumber = 19

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _DiceRollParserCitronErrorCaptureDelegate : AnyObject {
    func shouldSaveErrorForCapturing(error: Error) -> Bool

    /* expr */
    func shouldCaptureErrorOnExpr(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<Expression>

    /* root */
    func shouldCaptureErrorOnRoot(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<Expression>

    /* modifier */
    func shouldCaptureErrorOnModifier(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<Modifier>

    /* compare_point */
    func shouldCaptureErrorOnCompare_point(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<ComparisonPoint>

    /* dice */
    func shouldCaptureErrorOnDice(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<Dice>
}

extension _DiceRollParserCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension DiceRollParser.CitronSymbolCode {
    static func == (a: DiceRollParser.CitronSymbolCode, b: DiceRollParser.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: DiceRollParser.CitronTokenCode, b: DiceRollParser.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: DiceRollParser.CitronSymbolCode, b: DiceRollParser.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: DiceRollParser.CitronNonTerminalCode, b: DiceRollParser.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension DiceRollParser.CitronSymbolCode {
    static func ~= (pattern: DiceRollParser.CitronTokenCode, value: DiceRollParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: DiceRollParser.CitronNonTerminalCode, value: DiceRollParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
