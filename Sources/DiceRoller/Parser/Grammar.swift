// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Preface

#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 13)

import CitronParserModule
import CitronLexerModule

#sourceLocation()

// Parser class

class DiceRollParser: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case Explode                        =   1
      case Compound                       =   2
      case Penetrate                      =   3
      case Reroll                         =   4
      case RerollOnce                     =   5
      case Critical                       =   6
      case Fumble                         =   7
      case Sort                           =   8
      case Equal                          =   9
      case NotEqual                       =  10
      case Greater                        =  11
      case GreaterEqual                   =  12
      case Lesser                         =  13
      case LesserEqual                    =  14
      case Add                            =  15
      case Subtract                       =  16
      case Multiply                       =  17
      case Divide                         =  18
      case Modulo                         =  19
      case Power                          =  20
      case Die                            =  21
      case Integer                        =  22
      case Percent                        =  23
      case Fudge                          =  24
      case FateSides                      =  25
      case Fail                           =  26
      case KeepHigh                       =  27
      case KeepLow                        =  28
      case DropLow                        =  29
      case DropHigh                       =  30
      case Min                            =  31
      case Max                            =  32
      case SortAscending                  =  33
      case SortDescending                 =  34
      case OpenParen                      =  35
      case CloseParen                     =  36
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case expr                           =  37
      case expr_list                      =  38
      case root                           =  39
      case dice                           =  40
      case roll                           =  41
      case modifier_list                  =  42
      case modifier                       =  43
      case compare_point                  =  44
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 37) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 45) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = (token: Token, position: CitronLexerPosition)

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy5(Expression)
        case yy29([Expression])
        case yy30(Modifier)
        case yy40(Dice)
        case yy48([Modifier])
        case yy52(ComparisonPoint)
        case yy66(Roll)

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy5(let value): return value as Any
            case .yy29(let value): return value as Any
            case .yy30(let value): return value as Any
            case .yy40(let value): return value as Any
            case .yy48(let value): return value as Any
            case .yy52(let value): return value as Any
            case .yy66(let value): return value as Any
            }
        }
    }

    typealias CitronResult = Expression

    // Counts

    let yyNumberOfSymbols: Int = 45
    let yyNumberOfStates: Int = 42

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  ( 1, .SH(17)), ( 2, .SH(16)), ( 3, .SH(15)), ( 4, .SH(13)), ( 5, .SH(12)),
/*   5 */  ( 6, .SH(11)), ( 7, .SH(10)), (44, .RD(28)), ( 9, .SH(39)), (10, .SH(38)),
/*  10 */  (11, .SH(37)), (12, .SH(36)), (13, .SH(35)), (14, .SH(34)), (44, .RD(27)),
/*  15 */  (15, .SH( 9)), (16, .SH( 8)), (17, .SH( 7)), (18, .SH( 6)), (19, .SH( 5)),
/*  20 */  (20, .SH( 4)), (37, .SH(19)), (44, .RD(26)), (39, .ACCEPT),   (40, .SH( 2)),
/*  25 */  (41, .RD(38)), (27, .SH(32)), (28, .SH(31)), (29, .SH(30)), (30, .SH(29)),
/*  30 */  (31, .SH(28)), (32, .SH(27)), (33, .SR(29)), (34, .SR(30)), ( 0, .RD( 0)),
/*  35 */  (44, .RD(24)), (36, .SR(39)), ( 9, .SH(39)), (10, .SH(38)), (11, .SH(37)),
/*  40 */  (12, .SH(36)), (13, .SH(35)), (14, .SH(34)), (17, .SH( 7)), (18, .SH( 6)),
/*  45 */  (19, .SH( 5)), (20, .SH( 4)), (44, .RD(14)), (44, .RD(12)), (15, .SH( 9)),
/*  50 */  (16, .SH( 8)), (17, .SH( 7)), (18, .SH( 6)), (19, .SH( 5)), (20, .SH( 4)),
/*  55 */  (42, .RD(41)), (43, .SH( 1)), (44, .SH(33)), (42, .RD( 6)), (43, .SH( 1)),
/*  60 */  (44, .SH(33)), (37, .SH(18)), (22, .SH(41)), (44, .RD(10)), (40, .SH( 2)),
/*  65 */  (41, .RD(38)), (37, .SH(23)), (44, .RD( 8)), (37, .SH(24)), (40, .SH( 2)),
/*  70 */  (41, .RD(38)), (40, .SH( 2)), (41, .RD(38)), (20, .SH( 4)), (37, .SH(25)),
/*  75 */  (35, .SH( 3)), (37, .SH(26)), (40, .SH( 2)), (41, .RD(38)), (40, .SH( 2)),
/*  80 */  (41, .RD(38)), (37, .SH(20)), (22, .SR(22)), (37, .SH(21)), (40, .SH( 2)),
/*  85 */  (41, .RD(38)), (40, .SH( 2)), (41, .RD(38)), (22, .SR( 1)), (23, .SR( 2)),
/*  90 */  (24, .SH(40)), (22, .SR(21)), (22, .SR(19)), (22, .SR(20)), (22, .SR(17)),
/*  95 */  (22, .SR(16)), (45, .RD( 2)), (22, .SR(47)), (22, .SR(46)), (22, .SR(45)),
/* 100 */  (26, .SH(14)), (22, .SR(44)), (22, .SR(43)), (22, .SR(42)), (21, .SH(22)),
/* 105 */  (45, .RD( 2)), (45, .RD( 2)), (25, .SR( 4)),
    ]

    let yyShiftUseDefault: Int = 108
    let yyShiftOffsetMin: Int = -1
    let yyShiftOffsetMax: Int = 83
    let yyShiftOffset: [Int] = [
        /*     0 */    40,   -1,   -1,   40,   40,   40,   40,   40,   40,   40,
        /*    10 */    28,   28,   28,   28,   28,   28,   28,   28,    0,   34,
        /*    20 */    26,   26,   66,   53,   53,   53,   53,   60,   69,   70,
        /*    30 */    71,   72,   73,   74,   75,   76,   77,   79,   80,   81,
        /*    40 */    82,   83,
    ]

    let yyReduceUseDefault: Int = -38
    let yyReduceOffsetMin: Int =   -37
    let yyReduceOffsetMax: Int =   46
    let yyReduceOffset: [Int] = [
        /*     0 */   -16,   13,   16,   24,   29,   31,   37,   39,   44,   46,
        /*    10 */   -37,  -30,  -22,   -9,    3,    4,   19,   23,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .ERROR , .RD(40), .RD( 5), .ERROR , .ERROR ,
  /*     5 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    10 */  .ERROR , .ERROR , .RD(25), .RD(23), .ERROR ,
  /*    15 */  .RD(11), .RD( 9), .RD( 7), .ERROR , .ERROR ,
  /*    20 */  .RD(32), .RD(31), .ERROR , .RD(36), .RD(35),
  /*    25 */  .RD(34), .RD(33), .ERROR , .ERROR , .ERROR ,
  /*    30 */  .RD(18), .ERROR , .RD(15), .RD(13), .ERROR ,
  /*    35 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    40 */  .RD( 3), .RD(37),
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 39, nrhs: 1),
        (lhs: 40, nrhs: 3),
        (lhs: 40, nrhs: 3),
        (lhs: 40, nrhs: 3),
        (lhs: 40, nrhs: 4),
        (lhs: 41, nrhs: 1),
        (lhs: 41, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 42, nrhs: 3),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 2),
        (lhs: 43, nrhs: 1),
        (lhs: 43, nrhs: 1),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 3),
        (lhs: 37, nrhs: 1),
        (lhs: 37, nrhs: 1),
        (lhs: 37, nrhs: 3),
        (lhs: 42, nrhs: 1),
        (lhs: 42, nrhs: 2),
        (lhs: 44, nrhs: 2),
        (lhs: 44, nrhs: 2),
        (lhs: 44, nrhs: 2),
        (lhs: 44, nrhs: 2),
        (lhs: 44, nrhs: 2),
        (lhs: 44, nrhs: 2),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    var isTracingPrintsSymbolValues: Bool = false
    var isTracingPrintsTokenValues: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "Explode",
    /*  2 */ "Compound",
    /*  3 */ "Penetrate",
    /*  4 */ "Reroll",
    /*  5 */ "RerollOnce",
    /*  6 */ "Critical",
    /*  7 */ "Fumble",
    /*  8 */ "Sort",
    /*  9 */ "Equal",
    /* 10 */ "NotEqual",
    /* 11 */ "Greater",
    /* 12 */ "GreaterEqual",
    /* 13 */ "Lesser",
    /* 14 */ "LesserEqual",
    /* 15 */ "Add",
    /* 16 */ "Subtract",
    /* 17 */ "Multiply",
    /* 18 */ "Divide",
    /* 19 */ "Modulo",
    /* 20 */ "Power",
    /* 21 */ "Die",
    /* 22 */ "Integer",
    /* 23 */ "Percent",
    /* 24 */ "Fudge",
    /* 25 */ "FateSides",
    /* 26 */ "Fail",
    /* 27 */ "KeepHigh",
    /* 28 */ "KeepLow",
    /* 29 */ "DropLow",
    /* 30 */ "DropHigh",
    /* 31 */ "Min",
    /* 32 */ "Max",
    /* 33 */ "SortAscending",
    /* 34 */ "SortDescending",
    /* 35 */ "OpenParen",
    /* 36 */ "CloseParen",
    /* 37 */ "expr",
    /* 38 */ "expr_list",
    /* 39 */ "root",
    /* 40 */ "dice",
    /* 41 */ "roll",
    /* 42 */ "modifier_list",
    /* 43 */ "modifier",
    /* 44 */ "compare_point",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "root ::= expr(a)",
        /*   1 */ "dice ::= Integer(c) Die Integer(s)",
        /*   2 */ "dice ::= Integer(c) Die Percent",
        /*   3 */ "dice ::= Integer(c) Die Fudge",
        /*   4 */ "dice ::= Integer(c) Die Fudge FateSides(v)",
        /*   5 */ "roll ::= dice(d)",
        /*   6 */ "roll ::= dice(d) modifier_list(mods)",
        /*   7 */ "modifier ::= Explode",
        /*   8 */ "modifier ::= Explode compare_point(cp)",
        /*   9 */ "modifier ::= Compound",
        /*  10 */ "modifier ::= Compound compare_point(cp)",
        /*  11 */ "modifier ::= Penetrate",
        /*  12 */ "modifier ::= Penetrate compare_point(cp)",
        /*  13 */ "modifier ::= compare_point(cp)",
        /*  14 */ "modifier_list ::= compare_point(scp) Fail compare_point(fcp)",
        /*  15 */ "modifier ::= KeepHigh",
        /*  16 */ "modifier ::= KeepHigh Integer(a)",
        /*  17 */ "modifier ::= KeepLow Integer(a)",
        /*  18 */ "modifier ::= DropLow",
        /*  19 */ "modifier ::= DropHigh Integer(a)",
        /*  20 */ "modifier ::= DropLow Integer(a)",
        /*  21 */ "modifier ::= Min Integer(a)",
        /*  22 */ "modifier ::= Max Integer(a)",
        /*  23 */ "modifier ::= Reroll",
        /*  24 */ "modifier ::= Reroll compare_point(cp)",
        /*  25 */ "modifier ::= RerollOnce",
        /*  26 */ "modifier ::= RerollOnce compare_point(cp)",
        /*  27 */ "modifier ::= Critical compare_point(cp)",
        /*  28 */ "modifier ::= Fumble compare_point(cp)",
        /*  29 */ "modifier ::= SortAscending",
        /*  30 */ "modifier ::= SortDescending",
        /*  31 */ "expr ::= expr(a) Add expr(b)",
        /*  32 */ "expr ::= expr(a) Subtract expr(b)",
        /*  33 */ "expr ::= expr(a) Multiply expr(b)",
        /*  34 */ "expr ::= expr(a) Divide expr(b)",
        /*  35 */ "expr ::= expr(a) Modulo expr(b)",
        /*  36 */ "expr ::= expr(a) Power expr(b)",
        /*  37 */ "expr ::= Integer(a)",
        /*  38 */ "expr ::= roll(a)",
        /*  39 */ "expr ::= OpenParen expr(a) CloseParen",
        /*  40 */ "modifier_list ::= modifier(a)",
        /*  41 */ "modifier_list ::= modifier(a) modifier_list(b)",
        /*  42 */ "compare_point ::= Equal Integer(a)",
        /*  43 */ "compare_point ::= NotEqual Integer(a)",
        /*  44 */ "compare_point ::= Greater Integer(a)",
        /*  45 */ "compare_point ::= GreaterEqual Integer(a)",
        /*  46 */ "compare_point ::= Lesser Integer(a)",
        /*  47 */ "compare_point ::= LesserEqual Integer(a)",
    ]

    // Extra class members


    var currentDieMax: Int = 6


    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* root ::= expr(a) */
            func codeBlockForRule00(a: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 42)
 return a 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule00(a: a))
            }
        case 1: /* dice ::= Integer(c) Die Integer(s) */
            func codeBlockForRule01(c: (token: Token, position: CitronLexerPosition), s: (token: Token, position: CitronLexerPosition)) throws -> Dice {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 64)

    currentDieMax = s.token.value
    return .standard(sides: s.token.value, count: c.token.value)

#sourceLocation()
}
            if case .yy0(let c) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule01(c: c, s: s))
            }
        case 2: /* dice ::= Integer(c) Die Percent */
            func codeBlockForRule02(c: (token: Token, position: CitronLexerPosition)) throws -> Dice {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 68)

    currentDieMax = 100
    return .percent(count: c.token.value)

#sourceLocation()
}
            if case .yy0(let c) = yySymbolOnStack(distanceFromTop: 2) {
                return .yy40(try codeBlockForRule02(c: c))
            }
        case 3: /* dice ::= Integer(c) Die Fudge */
            func codeBlockForRule03(c: (token: Token, position: CitronLexerPosition)) throws -> Dice {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 72)

    currentDieMax = 1
    return .fate(lowProbability: false, count: c.token.value)

#sourceLocation()
}
            if case .yy0(let c) = yySymbolOnStack(distanceFromTop: 2) {
                return .yy40(try codeBlockForRule03(c: c))
            }
        case 4: /* dice ::= Integer(c) Die Fudge FateSides(v) */
            func codeBlockForRule04(c: (token: Token, position: CitronLexerPosition), v: (token: Token, position: CitronLexerPosition)) throws -> Dice {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 76)

    currentDieMax = 1
    return .fate(lowProbability: v.token.value == 1, count: c.token.value)

#sourceLocation()
}
            if case .yy0(let c) = yySymbolOnStack(distanceFromTop: 3),
               case .yy0(let v) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy40(try codeBlockForRule04(c: c, v: v))
            }
        case 5: /* roll ::= dice(d) */
            func codeBlockForRule05(d: Dice) throws -> Roll {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 86)

    return Roll(dice: d)

#sourceLocation()
}
            if case .yy40(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy66(try codeBlockForRule05(d: d))
            }
        case 6: /* roll ::= dice(d) modifier_list(mods) */
            func codeBlockForRule06(d: Dice, mods: [Modifier]) throws -> Roll {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 89)

    return Roll(dice: d, modifiers: mods)

#sourceLocation()
}
            if case .yy40(let d) = yySymbolOnStack(distanceFromTop: 1),
               case .yy48(let mods) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy66(try codeBlockForRule06(d: d, mods: mods))
            }
        case 7: /* modifier ::= Explode */
            func codeBlockForRule07() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 101)

    let cp = ComparisonPoint(comparison: .maxRoll, value: currentDieMax)
    return Modifiers.Explode(comparison: cp, format: .exploding)

#sourceLocation()
}
            return .yy30(try codeBlockForRule07())
        case 8: /* modifier ::= Explode compare_point(cp) */
            func codeBlockForRule08(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 105)

    return Modifiers.Explode(comparison: cp, format: .exploding)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule08(cp: cp))
            }
        case 9: /* modifier ::= Compound */
            func codeBlockForRule09() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 108)

    let cp = ComparisonPoint(comparison: .maxRoll, value: currentDieMax)
    return Modifiers.Explode(comparison: cp, format: .compounding)

#sourceLocation()
}
            return .yy30(try codeBlockForRule09())
        case 10: /* modifier ::= Compound compare_point(cp) */
            func codeBlockForRule10(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 112)

    return Modifiers.Explode(comparison: cp, format: .compounding)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule10(cp: cp))
            }
        case 11: /* modifier ::= Penetrate */
            func codeBlockForRule11() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 115)

    let cp = ComparisonPoint(comparison: .maxRoll, value: currentDieMax)
    return Modifiers.Explode(comparison: cp, format: .penetrating)

#sourceLocation()
}
            return .yy30(try codeBlockForRule11())
        case 12: /* modifier ::= Penetrate compare_point(cp) */
            func codeBlockForRule12(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 119)

    return Modifiers.Explode(comparison: cp, format: .penetrating)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule12(cp: cp))
            }
        case 13: /* modifier ::= compare_point(cp) */
            func codeBlockForRule13(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 125)

    return Modifiers.Success(comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule13(cp: cp))
            }
        case 14: /* modifier_list ::= compare_point(scp) Fail compare_point(fcp) */
            func codeBlockForRule14(scp: ComparisonPoint, fcp: ComparisonPoint) throws -> [Modifier] {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 128)

    return [
        Modifiers.Success(comparison: scp),
        Modifiers.Failure(comparison: fcp)
    ]

#sourceLocation()
}
            if case .yy52(let scp) = yySymbolOnStack(distanceFromTop: 2),
               case .yy52(let fcp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy48(try codeBlockForRule14(scp: scp, fcp: fcp))
            }
        case 15: /* modifier ::= KeepHigh */
            func codeBlockForRule15() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 137)

    return Modifiers.Keep(high: true, count: 1)

#sourceLocation()
}
            return .yy30(try codeBlockForRule15())
        case 16: /* modifier ::= KeepHigh Integer(a) */
            func codeBlockForRule16(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 140)

    return Modifiers.Keep(high: true, count: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule16(a: a))
            }
        case 17: /* modifier ::= KeepLow Integer(a) */
            func codeBlockForRule17(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 143)

    return Modifiers.Keep(high: false, count: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule17(a: a))
            }
        case 18: /* modifier ::= DropLow */
            func codeBlockForRule18() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 147)

    return Modifiers.Drop(high: false, count: 1)

#sourceLocation()
}
            return .yy30(try codeBlockForRule18())
        case 19: /* modifier ::= DropHigh Integer(a) */
            func codeBlockForRule19(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 150)

    return Modifiers.Drop(high: true, count: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule19(a: a))
            }
        case 20: /* modifier ::= DropLow Integer(a) */
            func codeBlockForRule20(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 153)

    return Modifiers.Drop(high: false, count: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule20(a: a))
            }
        case 21: /* modifier ::= Min Integer(a) */
            func codeBlockForRule21(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 159)

    return Modifiers.Minimum(value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule21(a: a))
            }
        case 22: /* modifier ::= Max Integer(a) */
            func codeBlockForRule22(a: (token: Token, position: CitronLexerPosition)) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 162)

    return Modifiers.Maximum(value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule22(a: a))
            }
        case 23: /* modifier ::= Reroll */
            func codeBlockForRule23() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 168)

    return Modifiers.Reroll()

#sourceLocation()
}
            return .yy30(try codeBlockForRule23())
        case 24: /* modifier ::= Reroll compare_point(cp) */
            func codeBlockForRule24(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 171)

    return Modifiers.Reroll(comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule24(cp: cp))
            }
        case 25: /* modifier ::= RerollOnce */
            func codeBlockForRule25() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 174)

    return Modifiers.Reroll(once: true)

#sourceLocation()
}
            return .yy30(try codeBlockForRule25())
        case 26: /* modifier ::= RerollOnce compare_point(cp) */
            func codeBlockForRule26(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 177)

    return Modifiers.Reroll(once: true, comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule26(cp: cp))
            }
        case 27: /* modifier ::= Critical compare_point(cp) */
            func codeBlockForRule27(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 183)

    return Modifiers.CriticalSuccess(comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule27(cp: cp))
            }
        case 28: /* modifier ::= Fumble compare_point(cp) */
            func codeBlockForRule28(cp: ComparisonPoint) throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 186)

    return Modifiers.CriticalFailure(comparison: cp)

#sourceLocation()
}
            if case .yy52(let cp) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy30(try codeBlockForRule28(cp: cp))
            }
        case 29: /* modifier ::= SortAscending */
            func codeBlockForRule29() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 192)

    return Modifiers.Sorting(ascending: true)

#sourceLocation()
}
            return .yy30(try codeBlockForRule29())
        case 30: /* modifier ::= SortDescending */
            func codeBlockForRule30() throws -> Modifier {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 195)

    return Modifiers.Sorting(ascending: false)

#sourceLocation()
}
            return .yy30(try codeBlockForRule30())
        case 31: /* expr ::= expr(a) Add expr(b) */
            func codeBlockForRule31(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 202)
 return .addition(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule31(a: a, b: b))
            }
        case 32: /* expr ::= expr(a) Subtract expr(b) */
            func codeBlockForRule32(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 203)
 return .subtraction(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule32(a: a, b: b))
            }
        case 33: /* expr ::= expr(a) Multiply expr(b) */
            func codeBlockForRule33(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 204)
 return .multiplication(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule33(a: a, b: b))
            }
        case 34: /* expr ::= expr(a) Divide expr(b) */
            func codeBlockForRule34(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 205)
 return .division(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule34(a: a, b: b))
            }
        case 35: /* expr ::= expr(a) Modulo expr(b) */
            func codeBlockForRule35(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 206)
 return .modulus(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule35(a: a, b: b))
            }
        case 36: /* expr ::= expr(a) Power expr(b) */
            func codeBlockForRule36(a: Expression, b: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 207)
 return .power(a, b) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule36(a: a, b: b))
            }
        case 37: /* expr ::= Integer(a) */
            func codeBlockForRule37(a: (token: Token, position: CitronLexerPosition)) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 212)
 return .number(a.token.value) 
#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule37(a: a))
            }
        case 38: /* expr ::= roll(a) */
            func codeBlockForRule38(a: Roll) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 213)
 return .roll(a) 
#sourceLocation()
}
            if case .yy66(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule38(a: a))
            }
        case 39: /* expr ::= OpenParen expr(a) CloseParen */
            func codeBlockForRule39(a: Expression) throws -> Expression {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 214)
 return .braced(a) 
#sourceLocation()
}
            if case .yy5(let a) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy5(try codeBlockForRule39(a: a))
            }
        case 40: /* modifier_list ::= modifier(a) */
            func codeBlockForRule40(a: Modifier) throws -> [Modifier] {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 222)
 return [a] 
#sourceLocation()
}
            if case .yy30(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy48(try codeBlockForRule40(a: a))
            }
        case 41: /* modifier_list ::= modifier(a) modifier_list(b) */
            func codeBlockForRule41(a: Modifier, b: [Modifier]) throws -> [Modifier] {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 223)
 return [a] + b 
#sourceLocation()
}
            if case .yy30(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy48(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy48(try codeBlockForRule41(a: a, b: b))
            }
        case 42: /* compare_point ::= Equal Integer(a) */
            func codeBlockForRule42(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 231)

    return ComparisonPoint(comparison: .equal, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule42(a: a))
            }
        case 43: /* compare_point ::= NotEqual Integer(a) */
            func codeBlockForRule43(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 234)

    return ComparisonPoint(comparison: .notEqual, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule43(a: a))
            }
        case 44: /* compare_point ::= Greater Integer(a) */
            func codeBlockForRule44(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 237)

    return ComparisonPoint(comparison: .greater, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule44(a: a))
            }
        case 45: /* compare_point ::= GreaterEqual Integer(a) */
            func codeBlockForRule45(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 240)

    return ComparisonPoint(comparison: .greaterEqual, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule45(a: a))
            }
        case 46: /* compare_point ::= Lesser Integer(a) */
            func codeBlockForRule46(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 243)

    return ComparisonPoint(comparison: .lesser, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule46(a: a))
            }
        case 47: /* compare_point ::= LesserEqual Integer(a) */
            func codeBlockForRule47(a: (token: Token, position: CitronLexerPosition)) throws -> ComparisonPoint {
#sourceLocation(file: "Sources/DiceRoller/Parser/Grammar.y", line: 246)

    return ComparisonPoint(comparison: .lesserEqual, value: a.token.value)

#sourceLocation()
}
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy52(try codeBlockForRule47(a: a))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy5(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _DiceRollParserCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [
          0 : [39, 40, 37],
          1 : [43, 43, 44],
          2 : [43, 43, 44],
          3 : [40, 37],
          4 : [40, 37],
          5 : [40, 37],
          6 : [40, 37],
          7 : [40, 37],
          8 : [40, 37],
          9 : [40, 37],
         10 : [44],
         11 : [44],
         12 : [44],
         13 : [44],
         14 : [44],
         15 : [44],
         16 : [44],
         17 : [44],
    ]
    let yyCanErrorCapture: Bool = true
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [
        37 : (endAfter: [],
              endBefore: [.CloseParen]),
        40 : (endAfter: [],
              endBefore: [.CloseParen]),
        43 : (endAfter: [],
              endBefore: [.CloseParen, .Add, .Subtract, .Multiply, .Divide, .Modulo, .Power]),
        44 : (endAfter: [],
              endBefore: [.CloseParen, .Add, .Subtract, .Multiply, .Divide, .Modulo, .Power])
    ]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = [
        15, 16, 17, 18, 19, 20, 36
    ]
    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = [
        
    ]

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        guard let delegate = errorCaptureDelegate else {
            print("Error capture: Not saving error for capturing because errorCaptureDelegate is not set")
            return false
        }
        return delegate.shouldSaveErrorForCapturing(error: error)
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        guard let delegate = errorCaptureDelegate else {
            print("Error capture: Not capturing error because errorCaptureDelegate is not set")
            return nil
        }

        switch (symbolCode) {
        case .expr:
            let delegateResponse = delegate.shouldCaptureErrorOnExpr(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy5(symbol)
            case .dontCapture:
                return nil
            }
        case .root:
            let delegateResponse = delegate.shouldCaptureErrorOnRoot(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy5(symbol)
            case .dontCapture:
                return nil
            }
        case .dice:
            let delegateResponse = delegate.shouldCaptureErrorOnDice(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy40(symbol)
            case .dontCapture:
                return nil
            }
        case .modifier:
            let delegateResponse = delegate.shouldCaptureErrorOnModifier(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy30(symbol)
            case .dontCapture:
                return nil
            }
        case .compare_point:
            let delegateResponse = delegate.shouldCaptureErrorOnCompare_point(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy52(symbol)
            case .dontCapture:
                return nil
            }
        default:
            fatalError("yyCaptureError: Symbol code \(symbolCode) is not an error capturing symbol code")
        }
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 39
    let yyEndStateNumber: CitronStateNumber = 19

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _DiceRollParserCitronErrorCaptureDelegate : AnyObject {
    func shouldSaveErrorForCapturing(error: Error) -> Bool

    /* expr */
    func shouldCaptureErrorOnExpr(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<Expression>

    /* root */
    func shouldCaptureErrorOnRoot(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<Expression>

    /* dice */
    func shouldCaptureErrorOnDice(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<Dice>

    /* modifier */
    func shouldCaptureErrorOnModifier(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<Modifier>

    /* compare_point */
    func shouldCaptureErrorOnCompare_point(state: DiceRollParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<ComparisonPoint>
}

extension _DiceRollParserCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension DiceRollParser.CitronSymbolCode {
    static func == (a: DiceRollParser.CitronSymbolCode, b: DiceRollParser.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: DiceRollParser.CitronTokenCode, b: DiceRollParser.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: DiceRollParser.CitronSymbolCode, b: DiceRollParser.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: DiceRollParser.CitronNonTerminalCode, b: DiceRollParser.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension DiceRollParser.CitronSymbolCode {
    static func ~= (pattern: DiceRollParser.CitronTokenCode, value: DiceRollParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: DiceRollParser.CitronNonTerminalCode, value: DiceRollParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
